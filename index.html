<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wave Lines UI (Three.js)</title>
  <style>
    /* ページ全体を白背景にしてスクロールバーを非表示 */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }
    /* Canvas を画面いっぱいに配置 */
    #container {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';

    let scene, camera, renderer, group;
    const lines = [];

    const params = {
      count: 400,             // 線の本数
      segments: 300,          // 1本あたりの分割数
      width: 10,              // 波全体の幅
      amplitude: 2,           // 中心ラインの振幅
      frequency: 0.2,         // 波の密度
      speedH: 0.01,           // 横に動く速さ
      phaseOffset: Math.PI/4, // ラインごとの位相差
      verticalAmplitude: 5,   // 全体の上下揺れ
      verticalSpeed: 0.01,    // 上下揺れの速さ
      verticalPhase: Math.PI/16 // ラインごとの上下位相差
    };

    init();
    animate();

    function init() {
      const container = document.getElementById('container');
      scene = new THREE.Scene();

      // アスペクト比に合わせたオーソカメラ
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = params.width;
      camera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,  frustumSize * aspect / 2,
         frustumSize / 2,          -frustumSize / 2,
         0.1, 100
      );
      camera.position.set(0, 0, 2);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff, 1);
      container.appendChild(renderer.domElement);

      // 線群をまとめて、斜めに回転
      group = new THREE.Group();
      group.rotation.z = -Math.PI / 8;
      scene.add(group);

      // 細いグレーの線、半透明
      const material = new THREE.LineBasicMaterial({
        color: 0x888888,
        opacity: 0.15,
        transparent: true,
        linewidth: 1
      });

      // 線を大量に生成
      for (let i = 0; i < params.count; i++) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array((params.segments + 1) * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), Infinity);

        const line = new THREE.Line(geometry, material);
        line.frustumCulled = false;
        group.add(line);
        lines.push(line);
      }

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = params.width;
      camera.left   = -frustumSize * aspect / 2;
      camera.right  =  frustumSize * aspect / 2;
      camera.top    =  frustumSize / 2;
      camera.bottom = -frustumSize / 2;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
      requestAnimationFrame(animate);
      updateLines(time * 0.001);
      renderer.render(scene, camera);
    }

    function updateLines(t) {
      const {
        count, segments, width,
        amplitude, frequency, speedH, phaseOffset,
        verticalAmplitude, verticalSpeed, verticalPhase
      } = params;

      for (let i = 0; i < count; i++) {
        const line = lines[i];
        const pos = line.geometry.attributes.position.array;

        const norm = (i / (count - 1) - 0.5) * 2;
        const envelope = Math.exp(-norm * norm * 4);
        const amp = amplitude * envelope;
        const baseY = norm * width / 2;
        const shiftY = verticalAmplitude * Math.sin(verticalSpeed * t + i * verticalPhase);
        const phase = i * phaseOffset;

        for (let j = 0; j <= segments; j++) {
          const x = (j / segments - 0.5) * width * (window.innerWidth / window.innerHeight);
          const y = baseY + shiftY + amp * Math.sin(
            frequency * (j / segments) * Math.PI * 4 - speedH * t + phase
          );
          const idx = j * 3;
          pos[idx]     = x;
          pos[idx + 1] = y;
          pos[idx + 2] = 0;
        }
        line.geometry.attributes.position.needsUpdate = true;
      }
    }
  </script>
</body>
</html>
